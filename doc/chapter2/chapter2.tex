\graphicspath{ {./chapter2/images/} }

\chapter{Проектиране на система за управление на пакети}


\section{Функционални изисквания}

Текущата дипломна работа цели реализирането на система за управление на пакети
за програмните езици C и C++. Като основна функционалност системата трябва да
предоставя възможност за:

\begin{itemize}
    \item Основни действия с пакети:
    \begin{itemize}
        \item[--] Инсталация на пакети от GitHub хранилище
        \item[--] Премахване на пакети
        \item[--] Изброяване на инсталираните пакети
        \item[--] Създаване на пакети и др.
    \end{itemize}
    \item Управление на зависимостите на даден пакет
    \begin{itemize}
        \item[--] Рекурсивна инсталация на всички зависимости на даден пакет
        \item[--] Проверка на съвместимостта на версиите на пакетите
    \end{itemize}
    \item Съхранение на списък с инсталираните пакети
    \begin{itemize}
        \item[--] Списък с локално инсталираните пакети се съхраняват в
                  \acrshort{json} файл в текущата директория
        \item[--] Списък с глобално инсталираните пакети се съхраняват в sqlite
                  база данни в главната директория на потребителя
    \end{itemize}
    \item Подаване на обратна връзка на потребителя
    \begin{itemize}
        \item[--] Изходни съобщения, показващи прогреса на инсталация/премахване
                  на пакетите
        \item[--] Диагностични съобщения, съхранявани в текстов файл в главната
                  директория на потребителя
    \end{itemize}
    \item Описание на характеристиките на пакетите чрез \acrshort{json} файлове
          (метаданни)
\end{itemize}


\section{Подбор на средства за разработка}

\subsection{Програмен език}

Текущата дипломна работа е реализирана на програмния език C++.

C++ е създаден през 80-те години на миналия век от датския програмист Бярне
Строуструп. Първоначалната цел на езика била да наподобява вече популярния език
C, като добави поддръжка за обектно-ориентирано програмиране (\acrshort{oop}).
От там идва и ранното му наименование - C с класове. Впоследствие обаче езикът
еволюира и започва да поддържа и други програмни парадигми, една от които е тази
на функционалното програмиране.

% Предимствата на езика са, че е бърз, заема малко количество памет

% Някои от главните му недостатъци са 

Основно езикът се използва за разработване на системи, при които е нужна висока
производителност и които са ограничени от страна на памет поради хардуера,
върху който се изпълняват. Въпреки това C++ разполага с богата стандартна
библиотека, предоставяща абстракции от високо ниво, с помощта на които могат
лесно да се разработват всякакъв вид програми. От тук обаче идва и един от
недостатъците на езика, а именно неговата сложност. С годините към C++ биват
добавени все повече и повече функционалности, които постепенно го правят все
по-комплексен и труднодостъпен за по-неопитните програмисти. Понеже се счита, че
езикът е с общо предназначение, има много спорове за какво и как трябва да бъде
използван. И все пак C++ остава един от най-популярните езици до ден днешен,
като стои в основата на много от критично важните системи, използвани ежедневно.

За разработката на текущия проект бе избран стандарта C++17 (формално
ISO/IEC 14882:2017) поради няколко причини:

\begin{itemize}
    \item C++17 е последната версия на езика, която е изцяло поддържана от
          главните компилатори - GCC и MSVC.
    \item от C++17 нататък стандартната библиотека предоставя удобни абстракции,
          някои от които са:
    \begin{itemize}
        \item[--] Интерфейс за работа с файловата система \\
                  (заглавния файл <filesystem>)
        \item[--] Поддръжка за типове с незадължителна стойност \\
                  (заглавния файл <optional>)
        \item[--] Поддръжка за олекотени низове, достъпни само за четене \\
                  (заглавния файл <string\_view>)
        \item[--] Поддръжка за структурирани свързвания \\
                  (structured bindings)
    \end{itemize}
    \item Съществуват множество свободно достъпни библиотеки, използващи
          модерните подобрения на езика
\end{itemize}


\subsection{Build система}

Много програмни езици в днешно време предоставят така наречената система за
изграждане (build system). Функциите на една такава система се различават в
зависимост от конкретния език, неговото предназначение и възможности,
но главната ѝ цел е да направи по-лесно компилирането/интерпретирането,
тестването и пакетирането на софтуер.

В случая на C++, различните операционни системи предоставят и собствени build
системи. Windows работи с Visual Studio проекти, Linux работи с Makefile и MacOS
работи с Xcode проекти. За да не е нужно да поддържаме три различни системи за
компилирането на един и същ проект, можем да използваме така нареченият
генератор на build системи (build system generator). Най-разпространеният такъв
е CMake (акроним за Cross Platform Make). Той е поддържан от всички главни
операционни системи, като автоматично генерира съответните build файлове, които
трябва да бъдат изпълнени, за да се компилира проекта. CMake също предоставя
допълнителни инструменти за автоматизирано тестване и пакетиране на софтуера
(CTest и CPack).
% Начинът ѝ на работа е следния:


\subsection{Система за управление на версиите}

Всеки един софтуерен проект в днешно време използва някакъв вид система за
управление на версиите. Най-разпространената такава система е git. Тя позволява
проследяването на всички промени по кода, като по този начин подпомага
сътрудничеството на големи екипи от хора.

По време на разработката на текущия проект бе използвана стратегия на
разклоненията (branching strategy), при която всяко изискване по проекта има
свое отделно разклонение:

\begin{itemize}
    \item cli - разработка на конзолния потребителски интерфейс
    \item commands - разработка на командите
    \item logger - разработка на диагностиката
    \item db - работа с sqlite базата данни, съхраняваща списъка с глобално
          инсталираните пакети
    \item script - работа с \acrshort{json} файла, съхраняващ списъка с локално
          инсталираните пакети
    \item dep-man - разработка на алгоритъма за управление на зависимостите
    \item doc - разработка на документацията
\end{itemize}


\subsection{Среда за разработка}

Текущата дипломна работа бе разработена на операционната система Arch Linux,
като за редакция на кода и документацията бе използван текстовият редактор
Visual Studio Code и неговото разширение, позволяващо използването на Vim
клавиши. Кодът на проекта бе публикуван онлайн в платформата GitHub. Настоящата
документация бе написана с помощта на \LaTeX.


\subsection{Непрекъсната интеграция (CI)}

Непрекъснатата интеграция (Continuous Integration) \figref{fig:ci-cd} e практика
при разработката на софтуер при която работата на много разработчици се
обединява на едно място, след което се задейства автоматизирана
компилация/интерпретация и тестване на софтуерния продукт.

\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{ci-cd-TEMP}
    \caption{Непрекъсната интеграция}
    \label{fig:ci-cd}
\end{figure}

По време на разработката на текущия проект бяха използвани предоставените от
платформата GitHub средства за автоматизирана компилация на кода (GitHub
Actions).


\subsection{Използвани библиотеки}

За реализирането на някои от функционалностите на проекта бяха използвани
следните библиотеки:

\begin{itemize}
    \item libcpr/cpr (C++ Requests) - обвивка (wrapper) на библиотеката curl,
          позволяваща изпълнение на \acrshort{http} заявки през мрежата
    \item kuba--/zip - библиотека за компресиране и архивиране
    \item sqlite - малка релационна база данни, съхранявана в един файл
    \item gabime/spdlog - библиотека, подаваща обратна връзка на потребителя и
          позволяваща пазенето на диагностични съобщения
    \item nlohmann/json - библиотека за работа с \acrshort{json} файлове
    \item p-ranav/argparse - библиотека, позволяваща лесна обработка на подадените към
          програмата параметри и тяхното използване
\end{itemize}


\subsection{Алгоритъм за управление на зависимостите}

За да се постигне ефективно и бързо инсталиране на даден пакет и неговите
зависимости, се разчита на наличието на lockfile в хранилището на всеки пакет.
По този начин се избягва изпълнението на множество заявки, които иначе биха били
нужни за построяването на графа на зависимостите на всеки пакет.

Инсталирането на даден пакет и неговите зависимости протича по следния начин:

\begin{enumerate}
    \item Сдобиване със lockfile на пакета и неговите зависимости
    \item Инсталиране на пакетите паралелно (в отделни нишки)
    \item Конструиране на графа на зависимостите във файловата система
\end{enumerate}

% \begin{lstlisting}[style=cpp, firstnumber=19,
%       caption={Примерен lockfile.json, описващ },
%       label={lst:install-check}]
% {
%     "dependencies": {
%         "A": {
%             "version": "1.0.0"
%             "dependencies": {
%                 "B": "1.0.0"
%                 "C": "2.0.0"
%             }
%         }
%         "B": {
%             "version": "1.0.0"
%             "dependencies": {
%                 "C": "2.0.0"
%             }
%         }
%         "C": {
%             "version": "2.0.0"
%         }
%     }
% }
% \end{lstlisting}

NP Hard



% Поради факта, че зависимостите на даден пакет формират дървовиден граф, можем да
% използваме алгоритъма за обхождане в дълбочина (Depth First Search)
% (фиг. \ref{fig:dfs}), за да минем през всички зависимости на всеки пакет и да ги
% инсталираме. Стъпките за изпълнение на алгоритъма са следните:

% \begin{enumerate}
%     \item \label{step:one} Инсталираме текущия пакет и посещаваме всички негови
%           зависимости подред.
%     \item Повтаряме стъпка (\ref{step:one}) докато не стигнем до пакет, който
%           няма зависимости.
%     \item Когато стигнем до пакет без зависимости го инсталираме и се връщаме
%           към родителския му пакет. Продължаваме изпълнението на стъпка
%           (\ref{step:one}).
%     \item Когато всички зависимости на даден пакет са инсталирани се връщаме към
%           родителския му пакет. Продължаваме изпълнението на стъпка
%           (\ref{step:one}).
%     \item Когато се върнем го началния пакет алгоритъмът приключва.
% \end{enumerate}

% \begin{figure}[h]
%     \centering
%     \includegraphics[width=1\textwidth]{dfs-TEMP}
%     \caption{Алгоритъм за обхождане в дълбочина}
%     \label{fig:dfs}
% \end{figure}
