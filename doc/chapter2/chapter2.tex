\graphicspath{ {./chapter2/images/} }

\chapter{Проектиране на система за управление на пакети}


\section{Функционални изисквания}

Текущата дипломна работа цели реализирането на система за управление на пакети
за програмните езици C и C++. Като основна функционалност системата трябва да
предоставя възможност за:

\begin{itemize}
    \item Основни действия с пакети:
    \begin{itemize}
        \item[--] Инсталация на пакети от GitHub хранилище
        \item[--] Премахване на пакети
        \item[--] Изброяване на инсталираните пакети
        \item[--] Създаване на пакети и др.
    \end{itemize}
    \item Управление на зависимостите на даден пакет
    \begin{itemize}
        \item[--] Рекурсивна инсталация на всички зависимости на даден пакет
        \item[--] Проверка на съвместимостта на версиите на пакетите
    \end{itemize}
    \item Съхранение на списък с инсталираните пакети
    \begin{itemize}
        \item[--] Списък с локално инсталираните пакети се съхраняват в
                  \acrshort{json} файл в текущата директория
        \item[--] Списък с глобално инсталираните пакети се съхраняват в sqlite
                  база данни в главната директория на потребителя
    \end{itemize}
    \item Подаване на обратна връзка на потребителя
    \begin{itemize}
        \item[--] Изходни съобщения, показващи прогреса на инсталация/премахване
                  на пакетите
        \item[--] Диагностични съобщения, съхранявани в текстов файл в главната
                  директория на потребителя
    \end{itemize}
    \item Описание на характеристиките на пакетите чрез \acrshort{json} файлове
          (метаданни)
\end{itemize}


\section{Подбор на средства за разработка}

\subsection{Програмен език}

Текущата дипломна работа е реализирана на програмния език C++.

C++ е създаден през 80-те години на миналия век от датския програмист Бярне
Строуструп. Първоначалната цел на езика била да наподобява вече популярния език
C, като добави поддръжка за обектно-ориентирано програмиране (\acrshort{oop}).
От там идва и ранното му наименование - C с класове. Впоследствие обаче езикът
еволюира и започва да поддържа и други програмни парадигми, една от които е тази
на функционалното програмиране.

% Предимствата на езика са, че е бърз, заема малко количество памет

% Някои от главните му недостатъци са 

Основно езикът се използва за разработване на системи, при които е нужна висока
производителност и които са ограничени от страна на памет поради хардуера,
върху който се изпълняват. Въпреки това C++ разполага с богата стандартна
библиотека, предоставяща абстракции от високо ниво, с помощта на които могат
лесно да се разработват всякакъв вид програми. От тук обаче идва и един от
недостатъците на езика, а именно неговата сложност. С годините към C++ биват
добавени все повече и повече функционалности, които постепенно го правят все
по-комплексен и труднодостъпен за по-неопитните програмисти. Понеже се счита, че
езикът е с общо предназначение, има много спорове за какво и как трябва да бъде
използван. И все пак C++ остава един от най-популярните езици до ден днешен,
като стои в основата на много от критично важните системи, използвани ежедневно.

За разработката на текущия проект бе избран стандарта C++17 (формално
ISO/IEC 14882:2017) поради няколко причини:

\begin{itemize}
    \item C++17 е последната версия на езика, която е изцяло поддържана от
          главните компилатори - GCC и MSVC.
    \item от C++17 нататък стандартната библиотека предоставя удобни абстракции,
          някои от които са:
    \begin{itemize}
        \item[--] Интерфейс за работа с файловата система \\
                  (заглавния файл <filesystem>)
        \item[--] Поддръжка за типове с незадължителна стойност \\
                  (заглавния файл <optional>)
        \item[--] Поддръжка за олекотени низове, достъпни само за четене \\
                  (заглавния файл <string\_view>)
        \item[--] Поддръжка за структурирани свързвания \\
                  (structured bindings)
    \end{itemize}
    \item Съществуват множество свободно достъпни библиотеки, използващи
          модерните подобрения на езика
\end{itemize}


\subsection{Build система}

Много програмни езици в днешно време предоставят така наречената система за
изграждане (build system). Функциите на една такава система се различават в
зависимост от конкретния език, неговото предназначение и възможности,
но главната ѝ цел е да направи по-лесно компилирането/интерпретирането,
тестването и пакетирането на софтуер.

В случая на C++, различните операционни системи предоставят и собствени build
системи. Windows работи с Visual Studio проекти, Linux работи с Makefile и MacOS
работи с Xcode проекти. За да не е нужно да поддържаме три различни системи за
компилирането на един и същ проект, можем да използваме така нареченият
генератор на build системи (build system generator). Най-разпространеният такъв
е CMake (акроним за Cross Platform Make). Той е поддържан от всички главни
операционни системи, като автоматично генерира съответните build файлове, които
трябва да бъдат изпълнени, за да се компилира проекта. CMake също предоставя
допълнителни инструменти за автоматизирано тестване и пакетиране на софтуера
(CTest и CPack).
% Начинът ѝ на работа е следния:


\subsection{Система за управление на версиите}

Всеки един софтуерен проект в днешно време използва някакъв вид система за
управление на версиите. Най-разпространената такава система е git. Тя позволява
проследяването на всички промени по кода, като по този начин подпомага
сътрудничеството на големи екипи от хора.

По време на разработката на текущия проект бе използвана стратегия на
разклоненията (branching strategy), при която всяко изискване по проекта има
свое отделно разклонение:

\begin{itemize}
    \item cli - разработка на конзолния потребителски интерфейс
    \item commands - разработка на командите
    \item logger - разработка на диагностиката
    \item db - работа с sqlite базата данни, съхраняваща списъка с глобално
          инсталираните пакети
    \item script - работа с \acrshort{json} файла, съхраняващ списъка с локално
          инсталираните пакети
    \item dep-man - разработка на алгоритъма за управление на зависимостите
    \item doc - разработка на документацията
\end{itemize}


\subsection{Среда за разработка}

Текущата дипломна работа бе разработена на операционната система Arch Linux,
като за редакция на кода и документацията бе използван текстовият редактор
Visual Studio Code и неговото разширение, позволяващо използването на Vim
клавиши. Кодът на проекта бе публикуван онлайн в платформата GitHub. Настоящата
документация бе написана с помощта на \LaTeX.


\subsection{Непрекъсната интеграция (\acrshort{ci})}

Непрекъснатата интеграция (Continuous Integration) \figref{fig:ci} e практика
при разработката на софтуер при която работата на много разработчици се
обединява на едно място, след което се задейства автоматизирана
компилация/интерпретация и тестване на софтуерния продукт.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{ci}
    \caption{Непрекъсната интеграция}
    \label{fig:ci}
\end{figure}

По време на разработката на текущия проект бяха използвани предоставените от
платформата GitHub средства за автоматизирана компилация на кода (GitHub
Actions).


\subsection{Използвани библиотеки}

За реализирането на някои от функционалностите на проекта бяха използвани
следните библиотеки:

\begin{itemize}
    \item libcpr/cpr (C++ Requests) - обвивка (wrapper) на библиотеката curl,
          позволяваща изпълнение на \acrshort{http} заявки \cite{cpr}
    \item kuba--/zip - библиотека за компресиране и архивиране
    \item sqlite - малка релационна база данни, съх
          \cite{sqlite}
    \item gabime/spdlog - библиотека, подаваща обратна връзка на потребителя и
          позволяваща пазенето на диагностични съобщения
    \item nlohmann/json - библиотека за работа с \acrshort{json} файлове
          \cite{json}
    \item p-ranav/argparse - библиотека, позволяваща лесна обработка на
          подадените към програмата параметри и тяхното използване
\end{itemize}


\subsection{Алгоритъм за управление на зависимостите}

За да се постигне ефективно и бързо инсталиране на даден пакет и неговите
зависимости, се разчита, че всеки пакет съдържа в хранилището си така наречения
lockfile, който представлява графа на неговите зависимости. По този начин се
избягва изпълнението на множество заявки, които иначе биха били нужни за
построяването на този граф. Инсталирането на даден пакет и неговите зависимости
се състои от следните стъпки:

\begin{enumerate}
    \item Сдобиване с lockfile на пакета и неговите зависимости
    \item Инсталиране на пакета и неговите зависимости паралелно (в отделни
          нишки)
    \item Конструиране на графа на зависимостите във файловата система,
          използвайки символични връзки (symlinks).
\end{enumerate}

Последната стъпка от изброените по-горе е така нареченият метод за изравняване
на зависимостите (dependency flattening \cite{npm}). Методът е илюстриран
по-долу чрез двете дървовидни структури, които са еквивалентни на графа, показан
по-рано \figref{fig:dep-graph}.

\begin{figure}[H]
    \centering
    \begin{minipage}{0.4\textwidth}
        \centering
        \includegraphics[width=.8\textwidth]{nested}
        \captionsetup{justification=centering}
        \caption{\\Дълбоко вложени зависимости}
        \label{fig:nested}
    \end{minipage}
    \begin{minipage}{0.05\textwidth}
        \centering
        $ \longrightarrow $
    \end{minipage}
    \begin{minipage}{0.4\textwidth}
        \centering
        \includegraphics[width=.4\textwidth]{flatten}
        \captionsetup{justification=centering}
        \caption{\\Изравнени зависимости}
        \label{fig:flatten}
    \end{minipage}
\end{figure}

От лявата страна \figref{fig:nested} е показано дърво на зависимостите, при
което всеки пакет съдържа в себе си всички свои зависимости. Това е
най-простият начин, по които могат да бъдат съхранени пакетите. Този подход
обаче има недостатъка, че с добавянето на нови зависимости към пакетите, които
все още нямат такива, се увеличава и нивото на влагане на пакетите.

От дясната страна \figref{fig:flatten} е показано дърво, при което всички
зависимости са съхранени на едно ниво. Така вместо всеки пакет да съдържа в себе
си своите зависимости, той съдържа символични връзки (обозначени със сиво на
фигурата), сочещи към предишната директория, в която зависимостите са
инсталирани. По този начин се решава проблема с влагането на пакети като нивата
на влагане се намаляват до максимум две.

% \begin{lstlisting}[style=cpp, firstnumber=19,
%       caption={Примерен lockfile.json, описващ },
%       label={lst:install-check}]
% {
%     "dependencies": {
%         "A": {
%             "version": "1.0.0"
%             "dependencies": {
%                 "B": "1.0.0"
%                 "C": "2.0.0"
%             }
%         }
%         "B": {
%             "version": "1.0.0"
%             "dependencies": {
%                 "C": "2.0.0"
%             }
%         }
%         "C": {
%             "version": "2.0.0"
%         }
%     }
% }
% \end{lstlisting}
